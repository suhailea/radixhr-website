"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  getIconCollections: () => getIconCollections,
  iconsPlugin: () => iconsPlugin
});
module.exports = __toCommonJS(src_exports);
var import_plugin = __toESM(require("tailwindcss/plugin.js"));
var import_utils2 = require("@iconify/utils");

// src/core.ts
var import_path = __toESM(require("path"));
var import_fs = __toESM(require("fs"));
var import_utils = require("@iconify/utils");
var req = true ? require : createRequire(import_meta.url);
var localResolve = (cwd, id) => {
  try {
    const resolved = req.resolve(id, { paths: [cwd] });
    return resolved;
  } catch {
    return null;
  }
};
function callerPath() {
  const error = new Error();
  const stack = error.stack?.split("\n");
  const data = stack.find(
    (line) => !line.trim().startsWith("Error") && !line.includes("(") && !line.includes(")")
  );
  if (!data) {
    return null;
  }
  const filePathPattern = new RegExp(
    /\s*at (\/.*|[a-zA-Z]:\\(?:([^<>:"\/\\|?*]*[^<>:"\/\\|?*.]\\|..\\)*([^<>:"\/\\|?*]*[^<>:"\/\\|?*.]\\?|..\\))?):\d+:\d+/i
  );
  const result = filePathPattern.exec(data);
  if (!result) {
    return null;
  }
  return result[1];
}
var isPackageExists = (id) => {
  const p = callerPath();
  const cwd = p ? import_path.default.dirname(p) : process.cwd();
  return Boolean(localResolve(cwd, id));
};
var getIconCollections = (include = "all") => {
  const p = callerPath();
  const cwd = p ? import_path.default.dirname(p) : process.cwd();
  const pkgPath = localResolve(cwd, "@iconify/json/package.json");
  if (!pkgPath) {
    if (Array.isArray(include)) {
      return include.reduce((result, name) => {
        const jsonPath = localResolve(cwd, `@iconify-json/${name}/icons.json`);
        if (!jsonPath) {
          throw new Error(
            `Icon collection "${name}" not found. Please install @iconify-json/${name} or @iconify/json`
          );
        }
        return {
          ...result,
          [name]: req(jsonPath)
        };
      }, {});
    }
    return {};
  }
  const pkgDir = import_path.default.dirname(pkgPath);
  const files = import_fs.default.readdirSync(import_path.default.join(pkgDir, "json"));
  const collections = {};
  for (const file of files) {
    if (include === "all" || include.includes(file.replace(".json", ""))) {
      const json = req(import_path.default.join(pkgDir, "json", file));
      collections[json.prefix] = json;
    }
  }
  return collections;
};
var generateIconComponent = (data, options) => {
  const css = (0, import_utils.getIconCSS)(data, {});
  const rules = {};
  css.replace(/^\s+([^:]+):\s*([^;]+);/gm, (_, prop, value) => {
    if (prop === "width" || prop === "height") {
      rules[prop] = `${options.scale}em`;
    } else {
      rules[prop] = value;
    }
    return "";
  });
  if (options.extraProperties) {
    Object.assign(rules, options.extraProperties);
  }
  return rules;
};

// types.ts
var availableCollectionNames = ["material-symbols", "ic", "mdi", "ph", "solar", "tabler", "ri", "bi", "carbon", "iconamoon", "ion", "uil", "teenyicons", "mingcute", "clarity", "iconoir", "majesticons", "zondicons", "ant-design", "bx", "bxs", "gg", "octicon", "cil", "lucide", "basil", "pixelarticons", "system-uicons", "ci", "akar-icons", "memory", "typcn", "radix-icons", "ep", "circum", "mdi-light", "fe", "eos-icons", "charm", "prime", "humbleicons", "uiw", "uim", "uit", "uis", "maki", "gridicons", "mi", "quill", "gala", "fluent", "icon-park-outline", "icon-park-solid", "icon-park-twotone", "icon-park", "vscode-icons", "jam", "heroicons", "codicon", "pajamas", "pepicons-pop", "pepicons-print", "pepicons-pencil", "bytesize", "ei", "streamline", "guidance", "fa6-solid", "fa6-regular", "ooui", "nimbus", "formkit", "line-md", "svg-spinners", "openmoji", "twemoji", "noto", "fluent-emoji", "fluent-emoji-flat", "fluent-emoji-high-contrast", "noto-v1", "emojione", "emojione-monotone", "emojione-v1", "fxemoji", "streamline-emojis", "bxl", "logos", "simple-icons", "cib", "fa6-brands", "nonicons", "arcticons", "file-icons", "devicon", "devicon-plain", "skill-icons", "brandico", "entypo-social", "cryptocurrency", "cryptocurrency-color", "flag", "circle-flags", "flagpack", "cif", "gis", "map", "geo", "game-icons", "fad", "academicons", "wi", "healthicons", "medical-icon", "covid", "la", "eva", "dashicons", "flat-color-icons", "entypo", "foundation", "raphael", "icons8", "iwwa", "heroicons-outline", "heroicons-solid", "fa-solid", "fa-regular", "fa-brands", "fa", "fluent-mdl2", "fontisto", "icomoon-free", "ps", "subway", "oi", "wpf", "simple-line-icons", "et", "el", "vaadin", "grommet-icons", "whh", "si-glyph", "zmdi", "ls", "bpmn", "flat-ui", "vs", "topcoat", "il", "websymbol", "fontelico", "feather", "mono-icons", "pepicons"];

// src/index.ts
var iconsPlugin = (iconsPluginOptions) => {
  const {
    collections: propsCollections,
    scale = 1,
    prefix = "i",
    extraProperties = {}
  } = iconsPluginOptions ?? {};
  const collections = propsCollections ?? getIconCollections(
    availableCollectionNames.filter(
      (name) => isPackageExists(`@iconify-json/${name}`)
    )
  );
  const components = {};
  for (const prefix2 of Object.keys(collections)) {
    const collection = {
      ...collections[prefix2],
      prefix: prefix2
    };
    (0, import_utils2.parseIconSet)(collection, (name, data) => {
      if (!data)
        return;
      components[`${prefix2}-${name}`] = generateIconComponent(data, {
        scale,
        extraProperties
      });
    });
  }
  return (0, import_plugin.default)(({ matchComponents }) => {
    matchComponents(
      {
        [prefix]: (value) => {
          if (typeof value === "string")
            return components[value];
          return value;
        }
      },
      {
        values: components
      }
    );
  });
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  getIconCollections,
  iconsPlugin
});
