// src/index.ts
import plugin from "tailwindcss/plugin.js";
import { parseIconSet } from "@iconify/utils";

// src/core.ts
import path from "path";
import fs from "fs";
import { getIconCSS, getIconData } from "@iconify/utils";
import { createRequire } from "module";
var req = false ? __require : createRequire(import.meta.url);
var localResolve = (cwd, id) => {
  try {
    const resolved = req.resolve(id, { paths: [cwd] });
    return resolved;
  } catch {
    return null;
  }
};
function callerPath() {
  const error = new Error();
  const stack = error.stack?.split("\n");
  const data = stack.find(
    (line) => !line.trim().startsWith("Error") && !line.includes("(") && !line.includes(")")
  );
  if (!data) {
    return null;
  }
  const filePathPattern = new RegExp(
    /\s*at (\/.*|[a-zA-Z]:\\(?:([^<>:"\/\\|?*]*[^<>:"\/\\|?*.]\\|..\\)*([^<>:"\/\\|?*]*[^<>:"\/\\|?*.]\\?|..\\))?):\d+:\d+/i
  );
  const result = filePathPattern.exec(data);
  if (!result) {
    return null;
  }
  return result[1];
}
var isPackageExists = (id) => {
  const p = callerPath();
  const cwd = p ? path.dirname(p) : process.cwd();
  return Boolean(localResolve(cwd, id));
};
var getIconCollections = (include = "all") => {
  const p = callerPath();
  const cwd = p ? path.dirname(p) : process.cwd();
  const pkgPath = localResolve(cwd, "@iconify/json/package.json");
  if (!pkgPath) {
    if (Array.isArray(include)) {
      return include.reduce((result, name) => {
        const jsonPath = localResolve(cwd, `@iconify-json/${name}/icons.json`);
        if (!jsonPath) {
          throw new Error(
            `Icon collection "${name}" not found. Please install @iconify-json/${name} or @iconify/json`
          );
        }
        return {
          ...result,
          [name]: req(jsonPath)
        };
      }, {});
    }
    return {};
  }
  const pkgDir = path.dirname(pkgPath);
  const files = fs.readdirSync(path.join(pkgDir, "json"));
  const collections = {};
  for (const file of files) {
    if (include === "all" || include.includes(file.replace(".json", ""))) {
      const json = req(path.join(pkgDir, "json", file));
      collections[json.prefix] = json;
    }
  }
  return collections;
};
var generateIconComponent = (data, options) => {
  const css = getIconCSS(data, {});
  const rules = {};
  css.replace(/^\s+([^:]+):\s*([^;]+);/gm, (_, prop, value) => {
    if (prop === "width" || prop === "height") {
      rules[prop] = `${options.scale}em`;
    } else {
      rules[prop] = value;
    }
    return "";
  });
  if (options.extraProperties) {
    Object.assign(rules, options.extraProperties);
  }
  return rules;
};

// types.ts
var availableCollectionNames = ["material-symbols", "ic", "mdi", "ph", "solar", "tabler", "ri", "bi", "carbon", "iconamoon", "ion", "uil", "teenyicons", "mingcute", "clarity", "iconoir", "majesticons", "zondicons", "ant-design", "bx", "bxs", "gg", "octicon", "cil", "lucide", "basil", "pixelarticons", "system-uicons", "ci", "akar-icons", "memory", "typcn", "radix-icons", "ep", "circum", "mdi-light", "fe", "eos-icons", "charm", "prime", "humbleicons", "uiw", "uim", "uit", "uis", "maki", "gridicons", "mi", "quill", "gala", "fluent", "icon-park-outline", "icon-park-solid", "icon-park-twotone", "icon-park", "vscode-icons", "jam", "heroicons", "codicon", "pajamas", "pepicons-pop", "pepicons-print", "pepicons-pencil", "bytesize", "ei", "streamline", "guidance", "fa6-solid", "fa6-regular", "ooui", "nimbus", "formkit", "line-md", "svg-spinners", "openmoji", "twemoji", "noto", "fluent-emoji", "fluent-emoji-flat", "fluent-emoji-high-contrast", "noto-v1", "emojione", "emojione-monotone", "emojione-v1", "fxemoji", "streamline-emojis", "bxl", "logos", "simple-icons", "cib", "fa6-brands", "nonicons", "arcticons", "file-icons", "devicon", "devicon-plain", "skill-icons", "brandico", "entypo-social", "cryptocurrency", "cryptocurrency-color", "flag", "circle-flags", "flagpack", "cif", "gis", "map", "geo", "game-icons", "fad", "academicons", "wi", "healthicons", "medical-icon", "covid", "la", "eva", "dashicons", "flat-color-icons", "entypo", "foundation", "raphael", "icons8", "iwwa", "heroicons-outline", "heroicons-solid", "fa-solid", "fa-regular", "fa-brands", "fa", "fluent-mdl2", "fontisto", "icomoon-free", "ps", "subway", "oi", "wpf", "simple-line-icons", "et", "el", "vaadin", "grommet-icons", "whh", "si-glyph", "zmdi", "ls", "bpmn", "flat-ui", "vs", "topcoat", "il", "websymbol", "fontelico", "feather", "mono-icons", "pepicons"];

// src/index.ts
var iconsPlugin = (iconsPluginOptions) => {
  const {
    collections: propsCollections,
    scale = 1,
    prefix = "i",
    extraProperties = {}
  } = iconsPluginOptions ?? {};
  const collections = propsCollections ?? getIconCollections(
    availableCollectionNames.filter(
      (name) => isPackageExists(`@iconify-json/${name}`)
    )
  );
  const components = {};
  for (const prefix2 of Object.keys(collections)) {
    const collection = {
      ...collections[prefix2],
      prefix: prefix2
    };
    parseIconSet(collection, (name, data) => {
      if (!data)
        return;
      components[`${prefix2}-${name}`] = generateIconComponent(data, {
        scale,
        extraProperties
      });
    });
  }
  return plugin(({ matchComponents }) => {
    matchComponents(
      {
        [prefix]: (value) => {
          if (typeof value === "string")
            return components[value];
          return value;
        }
      },
      {
        values: components
      }
    );
  });
};
export {
  getIconCollections,
  iconsPlugin
};
